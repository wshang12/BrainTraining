# 架构决策记录 (ADR)

## 概述

本文档记录了脑力训练 APP 的关键架构决策，解释每个决策背后的原因、考虑的替代方案，以及预期的结果。

## ADR-001: 游戏引擎架构

**状态**: 已实施  
**日期**: 2024-01-XX

### 背景
初始实现中，每个游戏都是独立的组件，包含自己的状态管理、渲染逻辑和数据收集。这导致了：
- 代码重复
- 性能监控不一致
- 数据格式各异
- 维护困难

### 决策
创建统一的 `GameEngine` 抽象基类，所有游戏都继承自此类。

```typescript
abstract class GameEngine extends EventEmitter {
  protected abstract update(deltaTime: number): void;
  protected abstract render(): void;
  // ... 其他抽象方法
}
```

### 考虑的替代方案
1. **组合模式**: 使用组合而非继承
   - 优点：更灵活
   - 缺点：对于游戏这种强生命周期的场景，继承更自然

2. **函数式方法**: 使用高阶函数
   - 优点：更容易测试
   - 缺点：状态管理复杂

### 结果
- ✅ 新游戏开发时间减少 70%
- ✅ 统一的性能监控
- ✅ 标准化的数据收集
- ⚠️ 需要重构现有游戏

## ADR-002: 状态管理方案

**状态**: 已实施  
**日期**: 2024-01-XX

### 背景
应用中存在多种状态：
- 用户信息和偏好
- 游戏进行状态
- 统计数据
- UI 状态

使用 useState 导致状态分散，难以管理。

### 决策
采用 Zustand 作为全局状态管理方案。

### 为什么选择 Zustand？
1. **轻量级**: 只有 2.9KB
2. **TypeScript 友好**: 完美的类型推导
3. **React 原生**: 不需要 Provider
4. **持久化简单**: 内置中间件支持

### 考虑的替代方案
1. **Redux Toolkit**
   - 优点：生态成熟，功能完整
   - 缺点：对于我们的场景过于复杂

2. **Jotai**
   - 优点：原子化状态管理
   - 缺点：学习曲线陡峭

3. **Valtio**
   - 优点：代理模式，使用简单
   - 缺点：社区相对较小

### 实现
```typescript
// User Store
const useUserStore = create<UserState>()(
  persist(
    (set, get) => ({
      // ... state and actions
    }),
    {
      name: 'user-store',
      storage: createJSONStorage(() => localStorage)
    }
  )
);
```

## ADR-003: 数据层架构

**状态**: 已实施  
**日期**: 2024-01-XX

### 背景
数据存储分散在各处：
- localStorage 直接调用
- 没有数据验证
- 没有统一的查询接口

### 决策
实现 Repository 模式，创建数据访问层。

### 设计原则
1. **单一职责**: 每个 Repository 管理一种实体
2. **统一接口**: 所有 Repository 实现相同的基础接口
3. **异步优先**: 所有方法返回 Promise，便于未来迁移
4. **类型安全**: 完整的 TypeScript 类型

### 实现
```typescript
abstract class BaseRepository<T> {
  abstract findById(id: string): Promise<T | null>;
  abstract create(data: Omit<T, 'id'>): Promise<T>;
  // ... 其他方法
}
```

### 未来考虑
- 迁移到 IndexedDB 以支持更大数据量
- 添加实时同步能力
- 实现乐观更新

## ADR-004: AI 服务架构

**状态**: 已实施  
**日期**: 2024-01-XX

### 背景
需要集成多个 AI 服务提供商：
- 不同的 API 格式
- 不同的限流策略
- 需要故障转移

### 决策
实现 AI 服务抽象层，支持多提供商和故障转移。

### 核心设计
1. **提供商抽象**: 统一的接口，不同的实现
2. **重试机制**: 指数退避 + 抖动
3. **故障转移**: 主服务失败自动切换
4. **负载均衡**: 在多个健康服务间分配请求

### 实现
```typescript
class AIServiceManager {
  private providers: AIProvider[];
  
  async complete(messages: Message[]): Promise<string> {
    return this.withRetry(
      () => this.loadBalance(messages)
    );
  }
}
```

## ADR-005: 性能优化策略

**状态**: 规划中  
**日期**: 2024-01-XX

### 背景
Canvas 游戏需要保持 60 FPS，同时：
- 移动设备性能有限
- 需要收集性能数据
- 电池消耗需要优化

### 决策
实施多层次性能优化策略。

### 优化方向
1. **渲染优化**
   - 脏矩形渲染
   - 对象池复用
   - 离屏 Canvas

2. **计算优化**
   - Web Worker 处理复杂计算
   - 空间分区减少碰撞检测

3. **资源优化**
   - 纹理图集
   - 音频精灵图
   - 渐进式加载

### 监控指标
- FPS (最小值、平均值、P95)
- 帧时间分布
- 内存使用
- 电池消耗估算

## ADR-006: 付费系统设计

**状态**: 已实施  
**日期**: 2024-01-XX

### 背景
需要设计可持续的商业模式，同时不影响用户体验。

### 决策
采用 Freemium + 订阅模式。

### 免费版价值
- 每日 3 次训练（足够体验价值）
- 基础数据统计
- 核心游戏体验

### Pro 版价值
- 无限训练次数
- 深度数据分析
- 专属游戏和功能
- 无广告体验

### 转化策略
1. **价值展示**: 在用户体验到价值后展示付费选项
2. **情感连接**: 基于用户成就和进步推荐升级
3. **社交压力**: 排行榜和成就系统的 Pro 特权

## 总结

这些架构决策的核心原则是：
1. **用户体验优先**: 技术服务于体验
2. **可扩展性**: 为未来功能预留空间
3. **可维护性**: 清晰的代码结构
4. **性能**: 流畅的交互体验

每个决策都经过深思熟虑，平衡了当前需求和未来发展。